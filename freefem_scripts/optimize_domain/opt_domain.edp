func string padint(int i, int len){ // pad int to given length with zeros
  string ss = i;
  int nn = ss.length; 
  for(int i=0;i<len-nn;i++)
    ss = "0"+ss;
  return ss;
}

cout << "parameters are in args.in -- Format : " << endl;
cout << "   nBoundary (number of points on boundary)"<<endl;
cout << "   eps (mesh fineness parameter)"<<endl;
cout << "   maxiter (maximum number of optimization iterations)"<<endl;
cout << "   lr (initial learning rate)"<<endl;
cout << "   lrmin (exit criterion on learning rate)"<<endl;
cout << "   lrdecay (decay parameter on learning rate)" <<endl;
cout << "   gamma (shape gradient regularization parameter)" <<endl;
cout << "   beta (inverse temperature)"<<endl;

ifstream args("args.in");

// io and algorithmic parameters
real eps,lr,lrmin,lrdecay,gamma,beta;
int nBoundary, maxiter;

args >> nBoundary >> eps >> maxiter >> lr >> lrmin >> lrdecay >> gamma >> beta;

string meshpath = "./meshes/";
string impath = "./img/";


int nev=2; // number of eigvals

ofstream objhist("./hists/objhist_"+beta+".out");
ofstream gradhist("./hists/gradhist_"+beta+".out");
ofstream l1hist("./hists/l1hist_"+beta+".out");
ofstream l2hist("./hists/l2hist_"+beta +".out");

func U = cos(2*pi*x)-cos(2*pi*(y-x));
    // computation of normalizing constant Z
    mesh cell = square(100,100,[-1.0 + 2*x, -1.0 + 2*y]); // mesh of "full" periodic cell
    fespace cellV(cell,P2);
    cellV mutilde =exp(-beta*U(x,y));
    real Z = int2d(cell)(mutilde);
    cout << "Z = " + Z << endl;

    cellV Ucell = U;
    plot(Ucell, wait=true,fill=true);

func mu = exp(-beta * U(x,y)) / Z;

// geometry

real r0 = 0.3, corex = -0.5, corey = 0.5;
border dOmega(t=0,2*pi){x = corex+r0*cos(t); y = corey+r0*(sin(t)+cos(t)); label=1;};

mesh Th = buildmesh(dOmega(nBoundary));
Th = adaptmesh(Th,eps,IsMetric=true,iso=true,nbvx=100000);
plot(Th,wait = 1);

// FE spaces and variables

fespace Vh(Th,P1); // for eigenproblem
fespace Vhvec(Th,[P1,P1]); // for shape perturbations

Vh Uh = U; // interpolated potential
Vh muh = mu; // interpolated mu 

// plot(Uh,value=true,fill=true,wait=true,boundary=true,dim=3);
// plot(muh,value=true,fill=true,wait=true,boundary=true,dim=3);

varf a(u,v) = int2d(Th)((dx(u)*dx(v)+dy(u)*dy(v))*mu) + on(1,u=0); // variational lhs for weighted Dirichlet eigenproblem
varf b(u,v) = int2d(Th)(u*v*mu); // variational rhs

matrix A,B ;  // fem matrices

real[int] evalues(nev); // eigenvalues
Vh[int] evectors(nev); // eigenvectors

Vhvec [thetax,thetay] , [wx,wy]; // shape gradient extension variables

int iter = 0;
real grad;

mesh Thold;
real optJ = 0.;
real J;

while(iter < maxiter){
   A = a(Vh,Vh);
   B = b(Vh,Vh);

   int k = EigenValue(A,B,sym=true,sigma=0.0,value=evalues,vector=evectors,tol=1e-15); // compute eigenvalues
    J = (evalues[1]-evalues[0]) / evalues[0];
    cout << "Iteration "<< iter<< " : J = " + J << endl;

    if (J > optJ){
      optJ = J;

      l1hist << evalues[0]<<endl;
      l2hist << evalues[1] << endl;
      objhist << (evalues[1]-evalues[0]) / evalues[0] << endl;

      if(evectors[0](corex,corey) < 0) evectors[0] = -evectors[0];

      plot(evectors[0],value=true,fill=true,wait=debug,boundary=true,ps = impath + "/lambda1/" + padint(iter,4) +".eps" );
      plot(evectors[1],value=true,fill=true,wait=debug,boundary=true,ps = impath + "/lambda2/" + padint(iter,4) +".eps" );
      plot(Uh,value=true,fill=true,wait=debug,boundary=true,ps = impath + "/V/" + padint(iter,4) +".eps" );
      plot(Th,boundary=true,ps=impath + "/meshes/" +padint(iter,4) + ".eps");

      func phi =   evalues[1]*(dx(evectors[0])*N.x + dy(evectors[0])*N.y)^2 
                  - evalues[0]*(dx(evectors[1])*N.x + dy(evectors[1])*N.y)^2
                  ; // shape gradient, defined on the boundary -- up to direction

      grad = int1d(Th,1)(phi^2*muh);

      gradhist << grad << endl;
      
      problem extension([thetax,thetay],[wx,wy]) = int2d(Th)(gamma*(dx(thetax)*dx(wx) + dy(thetax)*dy(wx) + dx(thetay)*dx(wy)+dy(thetay)*dy(wy))
                                                          + thetax*wx + thetay*wy)
                                              -int1d(Th,1)(phi*(wx*N.x + wy*N.y));

      extension;

      plot([thetax,thetay],wait= debug,boundary=true,value=true,ps = impath + "/theta/" + padint(iter,4)+".eps");

      if(checkmovemesh(Th,[x+lr*thetax,y+lr*thetay]))
        Th = movemesh(Th,[x+lr*thetax,y+lr*thetay]);
      else
        Th = adaptmesh(Th,eps,IsMetric=true,iso=true,nbvx=100000);


      //savemesh(Th,meshpath + padint(iter,4)+".msh");
      Uh = U;
    //plot(Uh,fill=true,wait=debug,value=true,dim=3);

      iter++;

      l1hist.flush;
      l2hist.flush;
      objhist.flush;
      gradhist.flush;

      Thold = Th;
      lr = lr / lrdecay;
    }
    else{
      Th = Thold;
      lr = lr * lrdecay;
    }

    if( lr < lrmin) break;
}

plot(Uh,fill=true,wait=true);
savemesh(Th,"./meshes/final_conn_"+beta+".msh");