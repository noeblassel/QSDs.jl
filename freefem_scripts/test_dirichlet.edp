func string f(int i, int len){
   string ss = i;
   int nn = ss.length; 
   for(int i=0;i<len-nn;i++)
     ss = "0"+ss;
   return ss;
}

// Physics
real beta = 9.0;
func U = cos(2*pi*x)-cos(2*pi*(y-x));

// Geometry

int n = 5;

real[int] rs = [0.2,0.2,0.2,0.2];

real[int] corex = [-0.5,-0.5,0.5,0.5];
real[int] corey = [-0.5,0.5,-0.5,0.5];
int[int] inout = [-16*n,-16*n,16*n,-16*n];

int[int] gradmask = [1,1,0,1];

border top(t=1,-1){x=t; y=1; label=1;};
border left(t=1,-1){x=-1; y=t; label=2;};
border bottom(t=-1,1){x=t ; y=-1; label=3;};
border right(t=-1,1){x=1 ; y=t; label=4;};

real[int] gradLambda1(4);
real[int] gradLambda2(4);
real[int] gradObj(4);

real obj,s;


// opt
real maxLr = 1e-4;
real minLr = 1e-15;
real optv = 0.0;
real mulLr = 1.2;
real divLr = 0.8;
real lr = 1e-10;

ofstream objhist("objhist.txt");

int iter=0;
int maxIter=1000;


while(iter < maxIter){
  border cores(t=0,2*pi; i){x = corex[i]+rs[i]*cos(t); y = corey[i]+rs[i]*(sin(t)+cos(t)); label=4+i+1;};
  mesh Th = buildmesh(top(16*n) + right(16*n) + bottom(16*n) + left(16*n)+ cores(inout));
  Th= adaptmesh(Th,1./40,IsMetric=1,nbvx=15000);
  fespace Vh(Th, P1, periodic=[[1,x],[3,x],[2,y],[4,y]]);
  fespace Wh(Th,[P1,P1],periodic=[[1,x],[3,x],[2,y],[4,y]]);

  real Zh = int2d(Th)(exp(-beta * U(x,y)));
  Vh muh = exp(-beta * U(x,y)) /  Zh;

  varf a(u,v) = int2d(Th)((dx(u)*dx(v) + dy(u)*dy(v))*muh)
                  + on(5,6,8, u = 0);
  varf b([u],[v]) = int2d(Th)(u*v*muh);

  matrix M = a(Vh,Vh);
  matrix B = b(Vh,Vh);

  int nev=2;
  real[int] ev(nev);
  Vh[int] eV(nev);

  int k = EigenValue(M,B,sym=true,sigma=0.0,value=ev,vector=eV,tol=1e-15);
  real Zhnu = int2d(Th)(eV[0](x,y)*muh(x,y));
  Vh nuh = eV[0]*muh/Zhnu;

  // cout << "l1 = " << ev[0] << " ; l2 = " << ev[1] <<endl;
  // cout << "obj = " << (ev[1]-ev[0])/ev[0]<<endl;

  Vh u;
  for(int i=0;i<4;i++){
    Vh thetax = 4*(x-corex[i])+2*(y-corey[i]);
    Vh thetay = 2*(x-corex[i]+y-corey[i]);

    u = eV[0];
    gradLambda1[i] = -gradmask[i]*int1d(Th,4+i+1)((dx(u)*N.x + dy(u)*N.y)^2 * muh * (thetax*N.x + thetay*N.y))/beta;

    u = eV[1];
    gradLambda2[i] = -gradmask[i]*int1d(Th,4+i+1)((dx(u)*N.x + dy(u)*N.y)^2 * muh * (thetax*N.x + thetay*N.y))/beta;

  } // local shape perturbations like gradient of Hessian;

  gradObj = (ev[0]*gradLambda2 - ev[1]*gradLambda1);
  gradObj *= ev[0]^-2;

  s=0;

  for(int i=1;i<4;i++) s+=gradObj[i]^2;
  
  obj = (ev[1]-ev[0])/ev[0];

  cout << "Iteration: "<<iter<<", lr: "<< lr<<", obj: "<<obj<<", |grad|: "<<sqrt(s)<<endl;
  if(obj > optv){
    rs += lr*gradObj;
    objhist<< obj <<","<< endl;
    objhist.flush;
    lr *= mulLr;
    iter++;
    plot(Th);
  }
  else{
    lr *= divLr;
    if(lr < minLr) break;
  }

}